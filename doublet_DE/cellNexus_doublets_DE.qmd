---
title: "CellNexus Doublet Differential Expression Analysis"
author: "Mengyuan Shen"
format:
  html:
    theme: minty
    df-print: paged
    code-line-numbers: true
    embed-resources: true
    code-fold: true
    code-fold-default: true
knitr:
  opts_chunk:
    message: false
    warning: false
    echo: true
---

# Introduction

This report provides an overview of doublet differential expression analysis from cellNexus. It outlines the workflow steps, including data filtering, pseudobulk aggregation, quality control, dispersion estimation, DE analysis, and visualization.

```{r setup}
# .libPaths("/Library/Frameworks/R.framework/Versions/4.5-x86_64/Resources/library")

required_packages <- c(
#  "ggalluvial",
  "stringr",
#  "ggfittext",
  "dplyr",
  "purrr",
  "ggplot2",
  "SummarizedExperiment",
  "SingleCellExperiment",
  "viridis",
#  "packcircles",
  "ggrepel",
  "patchwork",
  "cellNexus",
  "tidySingleCellExperiment",
  "tidybulk",
  "edgeR",
  "tidySummarizedExperiment",
  "tidyr"
)

# Ensure rlang is present
if (!requireNamespace("rlang", quietly = TRUE)) {
  install.packages("rlang")
}

# Helper to check and install Bioc packages if missing

lapply(required_packages, function(pkg) {
  if (!rlang::is_installed(pkg)) {
    message(sprintf("Attempting to install missing package: %s", pkg))
    if (!requireNamespace("BiocManager", quietly = TRUE)) {
      install.packages("BiocManager")
    }
    BiocManager::install(pkg, ask = FALSE, update = FALSE)
    library(pkg, character.only = TRUE)
  }
})
#source(here::here("doublet_DE", "plot_custom_theme.R"))
#source(here::here("doublet_DE", "CAQ_age_analysis_functions.R"))
```

# Load and process data
```{r}
library(targets)

tar_script({
  library(targets)
  library(crew)
  library(crew.cluster)
  # Helper (optional) to avoid repetition
  new_elastic <- function(name,
                          mem_gb,
                          time_min,
                          workers,
                          crashes_max,
                          backup = NULL) {
    crew_controller_slurm(
      name = name,
      workers = workers,
      crashes_max = crashes_max,
      seconds_idle = 30,
      options_cluster = crew_options_slurm(
        memory_gigabytes_required = mem_gb,
        cpus_per_task = 2,
        time_minutes = time_min
      ),
      backup = backup
    )
  }
  
  # Small → large, with fallbacks to the next size up
  elastic_160 <- new_elastic("elastic_160",
                             160,
                             60 * 24,
                             workers = 8,
                             crashes_max = 2)
  elastic_80  <- new_elastic(
    "elastic_80",
    80,
    60 * 4,
    workers = 16,
    crashes_max = 1,
    backup = elastic_160
  )
  elastic_40  <- new_elastic(
    "elastic_40",
    40,
    60 * 4,
    workers = 24,
    crashes_max = 1,
    backup = elastic_80
  )
  elastic_20  <- new_elastic(
    "elastic_20",
    20,
    60 * 4,
    workers = 32,
    crashes_max = 1,
    backup = elastic_40
  )
  elastic_10  <- new_elastic(
    "elastic_10",
    10,
    60 * 4,
    workers = 200,
    crashes_max = 1,
    backup = elastic_20
  )
  elastic_5   <- new_elastic(
    "elastic_5",
    5,
    60 * 4,
    workers = 200,
    crashes_max = 6,
    backup = elastic_10
  )
  
  # Group for targets (small → large)
  controllers <- crew_controller_group(elastic_5,
                                       elastic_10,
                                       elastic_20,
                                       elastic_40,
                                       elastic_80,
                                       elastic_160)
  
  tar_option_set(
    memory = "transient",
    garbage_collection = 100,
    storage = "worker",
    retrieval = "worker",
    #error = "continue",
    
    #cue = tar_cue(mode = "never"),
    
    workspace_on_error = TRUE,
    format = "qs",
    
    workspaces = "estimates_chunk_633f6596569029e6",
    debug = "sample_aggregated",
    
    controller = controllers
    
  )
  
  get_my_metadata <- function() {
    get_metadata() |>
      filter(empty_droplet == FALSE, alive == TRUE, feature_count >= 8000) |>
      mutate(scDblFinder.class %in% c("singlet", "doublet"))
  }
  
  list(
    tar_target(
      my_cache_directory,
      "/vast/projects/cellxgene_curated/cellNexus/"
    ),
    tar_target(my_doublet_proportion, 0.05),
    tar_target(
      my_sample_id,
      get_my_metadata() |>
        count(sample_id, dataset_id, scDblFinder.class) |>
        mutate(doublet_proportion = n / sum(n), .by = sample_id) |>
        filter(scDblFinder.class == "doublet") |>
        filter(doublet_proportion > my_doublet_proportion) |>
        
        # get datasets with most samples
        collect() |>
        nest(data = -dataset_id) |>
        mutate(n_samples = map_int(data, ~ n_distinct(.x$sample_id))) |>
        arrange(desc(n_samples)) |>
        filter(n_samples >= 10) |>
        unnest(data) |>
        pull(sample_id) |>
        unique() ,

      packages = c("cellNexus", "dplyr", "tidyr", "purrr"),
      iteration = "list"
    ),
    tar_target(
      sample_aggregated,
      {
        sce <-
          get_my_metadata() |>
          filter(sample_id == my_sample_id) |>
          get_single_cell_experiment(cache_directory = my_cache_directory)
        
        sce |>
          scuttle::aggregateAcrossCells(
            colData(sce)[, c("sample_id", "scDblFinder.class")] |>
              as_tibble(rownames = ".cell") |>
              mutate(
                aggregated_cells = paste(sample_id, scDblFinder.class, sep = "___")
              ) |>
              pull(aggregated_cells)
            # ,
            # BPPARAM = BiocParallel::MulticoreParam(
            #   workers = parallelly::availableCores()
            # )
          )
      },
      pattern = map(my_sample_id),
      iteration = "list",
      packages = c(
        "cellNexus",
        "scuttle",
        "dplyr",
        "BiocParallel",
        "parallelly"
      )
    ),
    
    # Get shared genes across all samples
    tar_target(
      genes_list,
      sample_aggregated |> rownames(),
      packages = c("SummarizedExperiment", "dplyr", "tidyr"),
      pattern = map(sample_aggregated),
      iteration = "list"
    ),
    tar_target(shared_genes, genes_list |> Reduce(intersect, x = _)),
    tar_target(
      sample_aggregated_filtered,
      {
        sample_aggregated =
          sample_aggregated[rownames(sample_aggregated) %in% shared_genes, ]
        
        rn = rownames(sample_aggregated)
        
        sample_aggregated =
          sample_aggregated |>
          as("SummarizedExperiment")
        
        rownames(sample_aggregated) = rn
        
        sample_aggregated
      },
      packages = c(
        "SummarizedExperiment",
        "dplyr",
        "tidyr",
        "tidySingleCellExperiment",
        "purrr"
      ),
      pattern = map(sample_aggregated),
      iteration = "list"
    ),
    tar_target(
      se_dataset,
      {
        se =
          sample_aggregated_filtered |>
          map(~ .x |> select(.feature, .sample, counts, contains("_id"), scDblFinder.class, ncells)) |> 
          do.call(cbind, args = _)
        
        dp =
          se |>
          pivot_sample() |>
          mutate(doublet_proportion = ncells / sum(ncells),
                 .by = sample_id) |>
          filter(scDblFinder.class == "doublet") |>
          distinct(sample_id, doublet_proportion)
        
        se |>
          left_join(dp) |>
          filter(doublet_proportion > my_doublet_proportion) |>
          filter(ncells > 10) |>
          filter(sample_id %in% (
            se |> pivot_sample() |> count(sample_id) |> filter(n == 2) |> pull(sample_id)
          )) |>
          filter(dataset_id %in% (
            se |> pivot_sample() |> count(dataset_id) |> filter(n > 10) |> pull(dataset_id)
          )) |>
          group_split(dataset_id) |> 
          
          # Filter small datasets
          map(~ { if(.x |> ncol() > 6 ) .x else NA}) |> 
          discard(is_na)
      },
      iteration = "list",
      packages = c("tidySummarizedExperiment", "SummarizedExperiment", "tidybulk", "rlang")
    ),
    tar_target(
      se_de,
      {
        se_dataset |>
          
          mutate(
            symbol = AnnotationDbi::mapIds(
              org.Hs.eg.db::org.Hs.eg.db,
              keys = .feature,
              keytype = "ENSEMBL",
              column = "SYMBOL",
              multiVals = "first"
            )
          ) |>
          mutate(
            entrez = AnnotationDbi::mapIds(
              org.Hs.eg.db::org.Hs.eg.db,
              keys = .feature,
              keytype = "ENSEMBL",
              column = "ENTREZID",
              multiVals = "first"
            )
          ) |>
          mutate(scDblFinder.class  = scDblFinder.class |> fct_relevel("singlet", "doublet")) |>
          
          keep_abundant(
            formula_design = ~ scDblFinder.class,
            minimum_count_per_million = 20
          )  |>
          scale_abundance(method = "TMMwsp") |>
          test_differential_expression(
            .formula = ~  scDblFinder.class + sample_id,
            scaling_method = "TMMwsp",
            test_above_log2_fold_change = 1,
            method = "edger_robust_likelihood_ratio",
          )
      },
      iteration = "list",
      pattern = map(se_dataset),
      packages = c(
        "org.Hs.eg.db",
        "tidySummarizedExperiment",
        "dplyr",
        "tidyr",
        "tidybulk",
        "purrr", "forcats"
      )
    ),
    tar_target(
      gsea,
      se_de |>
        
        filter(!entrez |> is.na()) |>
        filter(!entrez |> duplicated()) |>
        test_gene_rank(
          .entrez = entrez,
          species = "Homo sapiens",
          .arrange_desc = logFC,
          gene_sets = "c2"
        ),
      iteration = "list",
      pattern = map(se_de),
      packages = c(
        "tidySummarizedExperiment",
        "dplyr",
        "tidyr",
        "tidybulk",
        "purrr"
      )
    ),
    
    tar_target(
      gsea_plot,
      gsea |>
        
        unnest(test) |>
        filter(Description |> str_detect("ADH")) |>
        filter(p.adjust <= 0.05) |>
        mutate(plot = pmap(
          list(fit, ID, idx_for_plotting, p.adjust),
          ~ enrichplot::gseaplot2(
            ..1,
            geneSetID = ..3,
            title = sprintf("%s \nadj pvalue %s", ..2, round(..4, 2)),
            base_size = 6,
            rel_heights = c(1.5, 0.5),
            subplots = c(1, 2)
          )
        )) |>
        pull(plot),
      iteration = "list",
      pattern = map(gsea),
      packages = c(
        "tidySummarizedExperiment",
        "dplyr",
        "tidyr",
        "purrr", "stringr"
      )
    )
    
  )
}, ask = FALSE, script = here::here("doublet_DE", "_targets.R"))

tar_make(script = here::here("doublet_DE", "_targets.R"),
         store = "/vast/scratch/users/mangiola.s/doublet_DE/targets")

tar_workspace(
  se_dataset,
  script = here::here("doublet_DE", "_targets.R"),
 store = "/vast/scratch/users/mangiola.s/doublet_DE/targets"
)
```

```{r}
library(targets)
library(tidySummarizedExperiment)
library(tidybulk)
library(here)
library(forcats)
library(magrittr)

# Adhesion genes
library(tibble)

library(tibble)
library(dplyr)
library(tidyr)
library(purrr)
library(stringr)
        library(enrichplot)
  library(patchwork)

doublet_markers <- tribble(
  ~category,                 ~symbol,                                                                                           ~rationale,
  "Erythroid / ambient",     c("HBA1","HBA2","HBB","HBG1","HBG2","HBD","ALAS2","AHSP"),                                          "Erythrocyte RNA in non-erythroid cells.",
  "Platelet / megakary",     c("PF4","PPBP","ITGA2B","ITGB3","NRGN","SPARC","THBS1"),                                            "Platelets adhering to other cells.",
  "Mitochondrial / stress",  c("MT-CO1","MT-CO2","MT-ATP6","MT-ND1","MT-ND2","FOS","JUN","JUNB","DUSP1","HSPA1A","HSP90AA1"),   "Damage or stress in multiplets.",
  "Adhesion / ECM mix",      c("CD44","VIM","ANXA2","LGALS1","FN1","SPARC"),                                                     "Cross-lineage adhesion signatures.",
  "Integrins",   c("ITGA6","ITGB5","ITGA1","ITGB8-AS1","ITGA5","ITGA7","ITGA11","ITGAX","ITGA2B","ITGA3"),           "Integrins specifically requested for doublet screening."
) %>%
  mutate(symbol = as.list(symbol))  |>
  unnest_longer(symbol) 

adhesion_genes_signature <- c(
  "CDH2","CDH3","CDH4","CDH5","CDH15","CD226","CLDN16","CNTN1","CLDN4","CLDN3",
  "CLDN7","CLDN23","VCAN","CTLA4","CLDN19","ALCAM","NLGN1","NFASC","ICOSLG",
  "CLDN14","CADM1","CLDN15","NEGR1","NECTIN3","CNTNAP2","CLDN17","GLG1",
  "CD274","ICOS","HLA-A","HLA-B","HLA-C","HLA-DMA","HLA-DMB","HLA-DOA",
  "HLA-DOB","HLA-DPA1","HLA-DPB1","HLA-DQA1","HLA-DQA2","HLA-DQB1","HLA-DRA",
  "HLA-DRB1","HLA-DRB3","HLA-DRB4","HLA-DRB5","HLA-E","HLA-F","HLA-G","ICAM1",
  "ICAM2","ICAM3","ITGA6","ITGA4","ITGA9","ITGAL","ITGAM","ITGAV","ITGB1",
  "ITGB2","ITGB7","ITGB8","L1CAM","MAG","CD99","MPZ","NCAM1","NCAM2","NEO1",
  "NRCAM","OCLN","CLDN20","CLDN11","F11R","CLDN18","PDCD1","PECAM1","CLDN22",
  "NLGN3","NLGN4X","NLGN2","CADM3","PTPRC","PTPRF","PTPRM","PVR","NECTIN1",
  "NECTIN2","JAM2","SDC1","SDC2","SDC4","SELE","SELL","SELP","SELPLG",
  "SIGLEC1","SPN","CNTN2","CLDN5","VCAM1","PDCD1LG2","CD276","MADCAM1","JAM3",
  "CNTNAP1","ITGA8","MPZL1","CLDN10","CLDN8","CLDN6","CLDN2","CLDN1","CLDN9",
  "ESAM","CD2","CD4","CD6","CD8A","CD8B","CD22","NRXN3","NRXN1","NRXN2","CD28",
  "CD80","CD86","CD34","CD40","CD40LG","CD58","SDC3","CDH1"
)

# Import theme_multipanel
source("https://gist.githubusercontent.com/stemangiola/fc67b08101df7d550683a5100106561c/raw/a0853a1a4e8a46baf33bad6268b09001d49faf51/ggplot_theme_multipanel")


  tar_read(gsea, store = "/vast/scratch/users/mangiola.s/doublet_DE/targets")[[1]] |> 
     unnest(test) |>
        filter(Description |> str_detect("ADH"))


```

```{r Density}
# Count distribution
se |> 
  ggplot(aes(counts_scaled+1, group=scDblFinder.class)) +
  geom_density(aes(color = scDblFinder.class)) +
  scale_x_log10()
```

```{r adjust and PCA, eval=FALSE}
# Adjust
se = 
  se |> 
  adjust_abundance(.factor_unwanted = "sample_id", .factor_of_interest = "scDblFinder.class", .abundance = counts_scaled)

# se |> saveRDS(here("doublet_DE", "se_adjusted.rds"))
# se = readRDS(here("doublet_DE", "se_adjusted.rds"))

# PCA
se |> 
  
  keep_variable(.abundance = counts_scaled_adjusted) |> 
  reduce_dimensions(method = "PCA", .abundance = counts_scaled_adjusted) |> 
  pivot_sample() |> 
  left_join(dp) |> 
  ggplot(aes(PC1, PC2, color = scDblFinder.class, shape = scDblFinder.class)) +
  geom_point(alpha = 0.5) +
  facet_wrap(~dataset_id) +
  guides(color="none")
```

Select the biggest dataset

```{r dataset selection}

 se = 
  se |> 
  nest(data = -dataset_id) |> 
  mutate(n_samples = map_int(data, ncol)) |> 
  filter(n_samples == max(n_samples)) |> 
  unnest(data)

```

```{r DE}

# library(mirai)
# daemons(
#   n = 10,
#   remote = cluster_config(command = "sbatch")
# )


# se |> saveRDS(here("doublet_DE", "se_adjusted_DE.rds"))
# se = readRDS(here("doublet_DE", "se_adjusted_DE.rds"))


# Check the model
library(edgeR)
se |>
   metadata() %$%
  tidybulk$edger_robust_likelihood_ratio_object |> 
    plotBCV()
```



```{r volcano}

se |>
        mutate(symbol = case_when(
          FDR<0.05 & symbol %in% c(doublet_markers$symbol, adhesion_genes) ~ symbol
        )) |> 
        
        mutate(
          color_group = case_when(
            FDR<0.05 & symbol %in% c(doublet_markers$symbol, adhesion_genes) ~ "significant_and_adhesion",
            FDR<0.05 ~ "significant",
            TRUE ~ "non-significant"
          )
        ) |> 
        pivot_transcript() |> 
        
         ggplot(aes(
      x = logFC,
      y = PValue
    )) +
  geom_point(aes(
    color = color_group,
    size = FDR<0.05,
    alpha = FDR<0.05
  )) +
  ggrepel::geom_text_repel(
    aes(label = symbol),
    box.padding = 0.1,
    size = 2,
    nudge_y = -0.02,
    max.overlaps = Inf,
    segment.size = 0.2,
    segment.color = "grey50"
  ) +
  theme(axis.title.x = element_text(hjust = 0.5)) +
  scale_x_continuous(
    name = expression(log[2] ~ "fold change (doublet vs singlet)")
  ) +
  tidybulk::scale_y_log10_reverse() +
  labs(y = expression(-log[10]~"P value")) +
    scale_color_manual(values = c("significant_and_adhesion" = "#e11f28", "significant" = "#2166ac", "non-significant" = "black"),
                       guide = "none") +
  scale_size_manual(values = c(`TRUE` = 0.5, `FALSE` = 0.2)) + 
  theme_multipanel +
    theme(axis.title.x = element_text(hjust = 0.5) ,
          axis.text.x = element_text(size = 5, hjust = 1)) +
    theme(legend.position = "none") +
    guides(fill = "none", color = "none")
   
# se |> saveRDS(here("doublet_DE", "se_adjusted_DE_GSE.rds"))
# se = readRDS(here("doublet_DE", "se_adjusted_DE_GSE.rds"))
```

```{r boxplot}


se |> 
  scale_abundance(method = "TMMwsp") |> 
  left_join(
    tibble(
      .feature = rownames(edger_obj),
      tagwise_dispersion = edger_obj$tagwise.dispersion,
      avg_log_CPM = edger_obj$AveLogCPM
    ), by = ".feature"
  ) |> 
  mutate(gate = tidygate::gate(
    avg_log_CPM, 
    tagwise_dispersion 
    #,programmatic_gates = readRDS(here("doublet_DE","tidygate.rds"))
  )) |> 
  filter(gate=="1") |> 
  ggplot(aes(scDblFinder.class, counts_scaled)) +
  geom_boxplot(outliers = FALSE) +
  geom_jitter() +
  scale_y_sqrt() +
  facet_wrap(~.feature, scale="free_y")

# Filter out high coefficient of variation
se = 
  se |> 
  left_join(
    tibble(
      .feature = rownames(edger_obj),
      tagwise_dispersion = edger_obj$tagwise.dispersion,
      avg_log_CPM = edger_obj$AveLogCPM
    ), by = ".feature"
  ) |> 
  filter(tagwise_dispersion<1)

rowData(se) = rowData(se)[,1,drop=FALSE]

# Second pass
se = se |> 
  
  keep_abundant(formula_design = ~scDblFinder.class, minimum_count_per_million = 20)  |>
   test_differential_expression(
    .formula = ~  scDblFinder.class + sample_id, 
    scaling_method = "TMMwsp", 
    test_above_log2_fold_change = 1,
    method = "edger_robust_likelihood_ratio",
  
  ) 



edger_obj = 
  se |>
  metadata() %$%
  tidybulk$edger_robust_likelihood_ratio_object 

edger_obj |>
  plotBCV()

se |> 
  scale_abundance(method = "TMMwsp") |> 
  filter(FDR<0.05) |> 
  as_tibble() |> 
  
  mutate(symbol = AnnotationDbi::mapIds(org.Hs.eg.db::org.Hs.eg.db, 
                                                                 keys = .feature, 
                                                                 keytype = "ENSEMBL", 
                                                                 column="SYMBOL", 
                                                                 multiVals = "first")) |>  
  filter(symbol |> str_detect("^ITG")) |>

  ggplot(aes(
    fct_relevel(scDblFinder.class, c("singlet")), counts_scaled, 
    group = sample_id
    #,color = sqrt(doublet_proportion)
  )) +
  geom_point() +
  geom_line() +
  scale_y_sqrt() +
  scale_color_distiller(palette = "Spectral") +
  facet_wrap(~symbol) +
  #theme_multipanel 
  theme_minimal()

# |> 
#   mutate(symbol = AnnotationDbi::mapIds(org.Hs.eg.db::org.Hs.eg.db, 
#                                         keys = .feature, 
#                                         keytype = "ENSEMBL", 
#                                         column="SYMBOL", 
#                                         multiVals = "first"))

x |> saveRDS(here("doublet_DE", "se_de.rds"))

x |> 
  filter(FDR<0.01) |> 
  filter(abs(logFC)>1) |> 
  pivot_transcript() |> 
  as_tibble() |> 
  mutate(symbol = AnnotationDbi::mapIds(org.Hs.eg.db::org.Hs.eg.db, 
                                        keys = .feature, 
                                        keytype = "ENSEMBL", 
                                        column="SYMBOL", 
                                        multiVals = "first")) |> 
  pull(symbol)
  


dp = 
  x |> 
  pivot_sample() |>  
  mutate(doublet_proportion = ncells/sum(ncells), .by = sample_id) |> 
  filter(scDblFinder.class == "doublet") |> 
  distinct(sample_id, doublet_proportion)

x |> 
  scale_abundance(method = "TMMwsp") |> 
  ggplot(aes(counts_scaled+1, group=scDblFinder.class)) +
  geom_density(aes(color = scDblFinder.class)) +
  scale_x_log10()


  

x |> 
  scale_abundance(method = "TMMwsp") |> 
  filter(FDR<0.05) |> 
  as_tibble() |> 
  mutate(symbol = AnnotationDbi::mapIds(org.Hs.eg.db::org.Hs.eg.db, 
                                                                 keys = .feature, 
                                                                 keytype = "ENSEMBL", 
                                                                 column="SYMBOL", 
                                                                 multiVals = "first")) |>  
  filter(symbol |> str_detect("^ITG")) |>

  ggplot(aes(scDblFinder.class, counts_scaled)) +
  geom_boxplot(outliers = FALSE) +
  geom_jitter(shape = ".") +
  scale_y_sqrt() +
  facet_wrap(~symbol, scale="free_y")

```


# Data Filtering and Pseudobulk Aggregation

This section filters cell metadata to select 195 samples from healthy European males aged 18–59, derived from blood tissue in two large datasets. It then identifies samples containing both singlet and doublet cells and aggregates the single-cell data into pseudobulk profiles for downstream analysis.

```{r}
# Filter metadata for relevant cells
x = cell_metadata |> filter(tissue_groups == "Blood",
                            disease == "normal",
                            ethnicity_groups == "European",
                            age_groups == "18-59",
                            sex == "male",
                            dataset_id %in% c("3faad104-2ab8-4434-816d-474d8d2641db",
                                              "b0e547f0-462b-4f81-b31b-5b0a5d96f537"),
                            empty_droplet == FALSE,
                            alive == TRUE,
                            scDblFinder.class != "Unknown") |>
  select(-run_from_cell_id, -X_umap1,-x_approximate_distribution,-X_umap2,
         -contains("metacell_"))

samples_celtype_single_doublet_tbl = x |>
  dplyr::count(sample_id, cell_type_unified_ensemble, scDblFinder.class, name = "n_cells") |>
  filter(n_cells > 10) |> 
  collect() |> 
  
  # For each sample and cell_type, keep those have both singlet and doublet
  dplyr::group_by(sample_id, cell_type_unified_ensemble) |>
  dplyr::filter(all(c("singlet", "doublet") %in% scDblFinder.class)) |>
  dplyr::ungroup()

```

```{r eval=FALSE}
sce = x |> 
  inner_join(samples_celtype_single_doublet_tbl |> 
               select(-n_cells), copy = T) |> 
  get_single_cell_experiment(cache_directory = "~/scratch/cellNexus")

cores = parallel::detectCores()-1
pseudobulk <- scuttle::aggregateAcrossCells(
  sce,
  colData(sce)[,c("sample_id","cell_type_unified_ensemble","scDblFinder.class")] |> 
    as_tibble(rownames = ".cell") |>
    mutate(aggregated_cells = paste(sample_id, cell_type_unified_ensemble,scDblFinder.class, sep = "___")) |>
    pull(aggregated_cells),
  BPPARAM = BiocParallel::MulticoreParam(workers = cores, progressbar = T)
)
```

```{r echo=FALSE}
# Optionally, load from HDF5 if available
pseudobulk = HDF5Array::loadHDF5SummarizedExperiment("doublet_de_1_0_12/")

```

# Pseudobulk Data Group Composition
## Sample and cell type summary
This section visualises the distribution of aggregated samples across different cell types and doublet/singlet status.

```{r}
# Number of singlet and doublet pseudobulk samples
pseudobulk |> dplyr::count(scDblFinder.class, name = "n_pseudobulk_sample") |> 
  mutate(scDblFinder.class = factor(scDblFinder.class, levels = c("singlet", "doublet"))) |>
  ggplot(aes(x = scDblFinder.class, y = n_pseudobulk_sample, fill = scDblFinder.class)) +
  geom_col(width = 0.6) +
  labs(
    x = "scDblFinder Class",
    y = "Number of Aggregated Samples"
  ) +
  scale_fill_manual(values = c("singlet" = "steelblue", "doublet" = "salmon")) +
  theme_minimal()
```

```{r fig.width=10, fig.height=6}
# Number of pseudobulk samples per cell type and class
pseudobulk |>
  dplyr::count(cell_type_unified_ensemble, scDblFinder.class, name = "n_pseudobulk_sample") |>
  group_by(cell_type_unified_ensemble) |>
  mutate(total = sum(n_pseudobulk_sample)) |>
  ungroup() |>
  mutate(
    cell_type_unified_ensemble = fct_reorder(cell_type_unified_ensemble, total, .desc = TRUE),
    scDblFinder.class = factor(scDblFinder.class, levels = c("singlet", "doublet"))
  ) |>
  ggplot(aes(
    x = scDblFinder.class,
    y = n_pseudobulk_sample,
    fill = scDblFinder.class
  )) +
  geom_col(width = 0.6) +
  facet_grid(~cell_type_unified_ensemble, switch = "x", scales = "free_x") +
  labs(
    x = "scDblFinder Class",
    y = "Number of Pseudobulk Samples"
  ) +
  scale_fill_manual(values = c("singlet" = "steelblue", "doublet" = "salmon")) +
  theme_minimal() +
  theme(
    axis.text.x = element_text(angle = 30, hjust = 1),
    strip.placement = "outside",
    strip.background = element_blank()
  )
```

## Filtering Summary
This section compares the number of samples and the proportions of cell types before and after filtering. This section demonstrates the impact of filtering on the dataset, showing how many samples and which cell types are retained.

```{r}
# Sample count before and after filtering
x |> left_join(samples_celtype_single_doublet_tbl |> 
                 mutate(filtered = TRUE), copy = T) |>
  mutate(filtered = ifelse(is.na(filtered), FALSE, filtered)) |>
  group_by(filtered) |> 
  summarise(n_samples = n_distinct(sample_id)) |>
  ggplot(aes(x = filtered, y = n_samples, fill = filtered)) +
  geom_col(width = 0.6) +
  labs(
    title = "Number of Sample IDs Before and After Filtering",
    x = "",
    y = "Sample Count"
  ) +
  scale_x_discrete(labels = c("FALSE" = "Before", "TRUE" = "After")) +
  scale_fill_manual(values = c("FALSE" = "grey70", "TRUE" = "steelblue")) +
  theme_minimal()
```

```{r}
x |> left_join(samples_celtype_single_doublet_tbl |> 
                 mutate(filtered = TRUE), copy = T) |>
  mutate(filtered = ifelse(is.na(filtered), FALSE, filtered)) |>
  dplyr::count(filtered, cell_type_unified_ensemble, name = "n_cells") |>
  group_by(filtered) |>
  mutate(proportion = n_cells / sum(n_cells)) |>
  ungroup() |>
  ggplot(aes(
    x = reorder(cell_type_unified_ensemble, -proportion, decreasing=T),
    y = proportion,
    fill = filtered
  )) +
  geom_col() +
  coord_flip() +
  scale_y_continuous(labels = scales::percent_format()) +
  scale_fill_manual(values = c("FALSE" = "grey70", "TRUE" = "steelblue"),
                    labels = c("Before", "After")) +
  labs(
    title = "Cell Type Proportions Before and After Filtering",
    x = "Cell Type",
    y = "Proportion",
    fill = "Filtering Status"
  ) +
  theme_minimal()
```

# QC and Normalization

This section performs quality control and normalization on the pseudobulk data. Outlier counts are capped at the 99th percentile per sample, and normalization (e.g., TMM) is applied. It visualizes the distribution of raw and normalized counts to assess the effect of normalization.

```{r}
library(tidybulk)

se = pseudobulk |>
  as("SummarizedExperiment")
rownames(se) <- rowData(pseudobulk) |> rownames()

# Quantile 99% Per Sample to cap outliers
counts <- assay(se, "counts") |> as.matrix()
cap_thresholds <- apply(counts, 2, function(col) quantile(col, probs = 0.99, na.rm = TRUE))
counts_capped <- sweep(counts, 2, cap_thresholds, FUN = pmin)
assay(se, "counts") <- counts_capped

se_norm = se |> scale_abundance()

# Plot counts and scaled counts distribution
df_long <- se_norm %>%
  pivot_longer(
    cols = c(counts, counts_scaled),
    names_to = "type",
    values_to = "value"
  ) %>%
  mutate(type = recode(type,
                       counts = "Raw counts",
                       counts_scaled = "TMM normalized counts"))

ggplot(df_long, aes(x = value)) +
  geom_histogram(bins = 50, fill = "steelblue", color = "white", linewidth = 0.2) +
  scale_x_log10() +
  facet_wrap(~type, scales = "free") +
  labs(
    x = expression(log[10]~"(Count)"),
    y = "Frequency",
    title = "Distribution of Raw vs TMM-normalized Counts"
  ) +
  theme_minimal(base_size = 10) +
  theme(
    plot.title = element_text(face = "bold", size = 12, hjust = 0.5),
    axis.text.x = element_text(angle = 30, hjust = 1),
    panel.grid.minor = element_blank()
  )
```

# Gene Filtering and Dispersion
This section evaluates how varying minimum count-per-million (minCPM) thresholds affect gene retention and dispersion estimates. For each threshold value (0 to 50), genes with low expression are filtered out, followed by normalization and dispersion estimation using a basic design model. The number of retained genes is recorded, and the biological coefficient of variation (BCV) plots are generated to assess variance trends across thresholds. These plots help inform the choice of an appropriate minCPM cutoff for downstream differential expression analysis.

::: {.panel-tabset group="minCPM"}
```{r}
#| output: asis
#| warning: false
#| echo: true
#| fig-width: 6
#| fig-height: 5

thresholds <- seq(0, 50, by = 10)
gene_counts <- data.frame(threshold = thresholds, n_genes = NA)

for (i in seq_along(thresholds)) {
  thres <- thresholds[i]
  se_filt <- se |> keep_abundant(minimum_count_per_million = thres) |> scale_abundance()
  design <- model.matrix(
    ~ scDblFinder.class,
    data = as.data.frame(colData(se_filt))
  )
  n_genes <- nrow(se_filt)
  gene_counts$n_genes[i] <- n_genes
  disp <- estimateDisp(se_filt, design = design)

  cat("## Threshold: ", thres, "\n\n")
  plotBCV(disp, main = paste("BCV Plot - minCPM =", thres))
  cat('\n\n')
}
```
:::

```{r}
# Plot number of genes retained at each threshold
ggplot(gene_counts, aes(x = threshold, y = n_genes)) +
  geom_line() +
  geom_point() +
  labs(
    x = "Minimum count per million (CPM)",
    y = "Number of genes retained",
    title = "Genes retained after minCPM filter"
  ) +
  theme_minimal()
```

We selected a minimum CPM threshold of 30 for the differential expression analysis, as it effectively reduces noise while retaining biologically meaningful genes.

# Differential Expression Analysis

This section performs differential expression analysis between doublet and singlet pseudobulk samples, adjusting for cell type and dataset. The section identifies significantly differentially expressed genes and extracts the top genes for further visualization.

```{r}
library(stringr)
library(tidyprint)
library(tidySummarizedExperiment)
tbl =
  se |> 
  keep_abundant(minimum_count_per_million = 30) |> 
  scale_abundance() |> 
  mutate(scDblFinder.class = factor(scDblFinder.class, levels = c("singlet", "doublet"))) |>
  mutate(cell_type_unified_ensemble_fixed = str_replace_all(cell_type_unified_ensemble, "[ /]", "_"),
         dataset_id_fixed = str_replace_all(dataset_id, "-", "_")) |> 
  test_differential_expression(
    .formula = ~ cell_type_unified_ensemble_fixed + dataset_id_fixed + scDblFinder.class,
    .contrasts = c("scDblFinder.classdoublet"), 
    method = "edger_robust_likelihood_ratio",
    omit_contrast_in_colnames = TRUE
  ) |> 
  mutate(symbol = AnnotationDbi::mapIds(org.Hs.eg.db::org.Hs.eg.db, 
                                        keys = as.character(.feature), 
                                        keytype = "ENSEMBL", 
                                        column="SYMBOL", 
                                        multiVals = "first")) |> 
  distinct(.feature, symbol, logFC, logCPM, PValue, FDR, .feature) |> 
  as_tibble() 
```

# MA Plot
MA plot is used to visualize the relationship between gene expression (log CPM) and log fold change between doublets and singlets. Significant genes are highlighted, providing a global view of differential expression results.

```{r fig.width=6, fig.height=5}
MA_p <- tbl |> 
  ggplot(aes(x = logCPM, y = logFC, color = FDR < 0.05)) +
  geom_point( size = 0.1) +
  scale_color_manual(values = c("black", "red")) +
  geom_hline(yintercept = 0, linetype = "dashed") +
  labs(
    title = "MA Plot",
    x = "log CPM",
    y = "log Fold Change"
  ) +   theme_multipanel
MA_p
```

# Volcano Plot

Volcano plot is generated to display the significance versus logFC (fold change) for all genes. Top significant genes are labeled, and up/down-regulated genes are color-coded, making it easy to identify the most differentially expressed genes.

```{r fig.width=6, fig.height=4}
tbl = tbl |> 
  filter(!is.na(symbol)) |> 
  mutate(significant = FDR < 0.05 & abs(logFC) >=0.7) 

sig_symbols <- tbl |> 
  filter(logFC>0 & significant) |> arrange(PValue) |>slice_head(n=3) |> 
  bind_rows(
    tbl |> filter(logFC<0 & significant) |> arrange(PValue) |>slice_head(n=3)
  ) |> pull(symbol) |> unique() # top DE genes

high_logfc_symbols <- tbl |> 
  filter(logFC > 0) |> 
  arrange(desc(logFC)) |> 
  slice_head(n = 3) |> 
  bind_rows(
    tbl |> 
      filter(logFC < 0) |> 
      arrange(logFC) |> 
      slice_head(n = 3)
  ) |> 
  distinct(symbol) |> 
  pull(symbol)

topgenes_symbols <- c(sig_symbols, high_logfc_symbols)

tbl_volcano <- tbl |> 
  mutate(
    significant = FDR < 0.05 & abs(logFC) >=0.7,
    symbol = as.character(symbol),
    symbol = ifelse(symbol %in% topgenes_symbols, symbol, ""),
    color_group = case_when(significant & logFC > 0 ~ "up",
                            significant & logFC < 0 ~ "down",
                            TRUE ~ "ns"))

volcano_p <- ggplot(tbl_volcano, aes(
  x = logFC,
  y = -log10(PValue)
)) +
  geom_point(aes(
    color = color_group,
    size = significant,
    alpha = significant
  )) +
  ggrepel::geom_text_repel(
    data = tbl_volcano %>% filter(symbol != "", color_group!= "ns"),
    aes(label = symbol),
    box.padding = 0.1,
    size = 2,
    nudge_y = -0.02,
    max.overlaps = Inf,
    segment.size = 0.2,
    segment.color = "grey50"
  ) +
  theme(axis.title.x = element_text(hjust = 0.5)) +
  scale_x_continuous(
    limits = c(-max(abs(tbl$logFC), na.rm = TRUE), max(abs(tbl$logFC), na.rm = TRUE)),
    name = expression(log[2] ~ "fold change (doublet vs singlet)")
  ) +
  labs(y = expression(-log[10]~"P value")) +
    scale_color_manual(values = c("up" = "#e11f28", "down" = "#2166ac", "ns" = "black"),
                       guide = "none") +
  scale_size_manual(values = c(`TRUE` = 0.5, `FALSE` = 0.2)) + 
  theme_multipanel +
    theme(axis.title.x = element_text(hjust = 0.5) ,
          axis.text.x = element_text(size = 5, hjust = 1)) +
    theme(legend.position = "none") +
    guides(fill = "none", color = "none")
volcano_p
``` 
Core doublet-upregulated = cell cycle + ribosomal + mixed lineage markers
STMN1 and SSRP1 make sense for doublet-up in blood pseudobulk; the others are not classic doublet markers and are more “dataset-specific / load” than “core doublet.”

Labelled upregulated genes:
•	STMN1 — plausible. Cell-cycle/microtubule; very commonly higher in doublets.
•	SSRP1 — plausible. FACT complex/chromatin; tracks proliferation/DNA replication load.
•	PGM2L1 — nonspecific metabolic/housekeeping; can drift up with bigger libraries but not a hallmark.
•	APPL1 — adaptor/scaffold, broadly expressed; not a known doublet flag.
•	COQ10B —️ mito-related; could reflect higher mitochondrial content in doublets, but not a standard marker.
•	FHIT —️ tumor-suppressor/fragile site; not a canonical doublet gene in blood.

Labelled downregulated genes:
APOBEC3G fits this model. The others (CFAP68, C12orf75, CHFR, RALBP1, PWWP3A) don’t have strong links to blood biology or doublets and are likely statistical noise, low-expression artifacts, or dataset-specific quirks.

•	Antiviral cytidine deaminase, highly expressed in lymphocytes (esp. T and NK cells). If doublets “dilute” lineage-specific signatures (e.g. a T cell mixed with something else), lineage-defining transcripts like APOBEC3G can appear down.

::: {.callout-note collapse="true" title="Session Info"}
```{r}
sessionInfo()
```
:::